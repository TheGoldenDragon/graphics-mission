<!DOCTYPE html>
<html lang="en">
<head>
<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>PoolTable Simulation</title>
<link rel="stylesheet" type="text/css" href="css/style.css">
</head>

<body>
<script src="js/three.js"></script>
<script src="js/OrbitControls.js"></script>
<script src="js/Detector.js"></script>

<div class="scoreboard" style="display: none;">
	<h2>Scoreboard (statistieken)</h2>
	<div class="inner">
    	<div class="scores">
        Aantal keren geschoten:<br>
        <p id="shotsfired">0</p>
        Aantal geraakte ballen met de witte bal:<br>
        <p id="ballshit"> 0</p>
        
        Aantal connecties tussen ballen:<br>
         <p id="connect"> 0</p>
         
          Extra informatie (debug):<br>
         <p id="debug"></p>
        </div>
    </div>
</div>
<div class="main">
<div class="logo"></div>
<canvas id="poolgame">
</canvas>
</div>

<script>
    if (!Detector.webgl) Detector.addGetWebGLMessage();

    var camera, controls, scene, renderer, whiteball, clock, poolGroup, cue;
    var shotsfired = 0;
    var mouse = new THREE.Vector2();
    var frameDeltaTime;

    var balls = [];

    document.addEventListener('mousemove', onDocumentMouseMove, true);
    document.addEventListener('keydown', onKeyDown, true);

    init(); //create objects e.g.
    render();

    function updateScoreboard() {
        shotsfired += 1;
        document.getElementById("shotsfired").innerHTML = shotsfired;
        document.getElementById("ballshit").innerHTML = cue.position.z + shotsfired;
        document.getElementById("connect").innerHTML = cue.position.x + shotsfired;

    }

    function render() {
        frameDeltaTime = clock.getDelta();
        controls.update();

        setCamera();
        calcPhysics(frameDeltaTime);
        renderer.render(scene, camera);
        requestAnimationFrame(render);
    }

    function onKeyDown(event) {
        event.preventDefault();
        switch (event.keyCode) {
            case 32:
                shootBall();
                break;
        }

    }

    function collideBall() { }
    function collideBorder() { }
    function calculatePos() { }
    function calcPhysics(clockDeltaTime) {
        //for each ball
        for (i = 0; i < balls.length; i++) {
            //console.log(balls[i]);
            //for each other ball
            if (balls[i].ball.speed <= 0)
                continue;

            for (x = 0; x < balls.length; x++) {
                if (balls[i].name == balls[x].name)
                    continue;

                var differenceVector = GetDistanceVector(balls[i].ball.position, balls[x].ball.position);
                var distance = Math.sqrt(differenceVector.x * differenceVector.x + differenceVector.y * differenceVector.y + differenceVector.z * differenceVector.z);

                if (distance < 1 + 1) {
                    var vectorNormal = GetVectorNormal(differenceVector, distance);
                    var vectorVelocityDelta = GetObjectVelocityDelta(balls[i], balls[x]);
                    var dotProduct = GetDotProduct(vectorVelocityDelta, vectorNormal);
                    if (dotProduct > 0) {
                        var coefficient = 0.5;
                        var impulseStrength = (1 + coefficient) * dotProduct;
                        var impulseVector = GetImpulseVector(impulseStrength, vectorNormal);

                        balls[i].direction = updateDirection(balls[i].direction, impulseVector, false);
                        balls[x].direction = updateDirection(balls[i].direction, impulseVector, true);

                        var iBallSpeed = balls[i].speed;
                        var xBallSpeed = balls[x].speed;

                        balls[i].ball.speed = xBallSpeed;
                        balls[x].ball.speed = iBallSpeed;
                    }
                }
                else {
                    //console.log(distance);
                }

            }
        }

        //Update ball positions
        for (i = 0; i < balls.length; i++) {
            if (balls[i].ball.speed <= 0) {
                continue;
            }

            //console.log(physicsItemsScript[i].dirXYZ);
            var translateX = balls[i].ball.speed * clockDeltaTime * balls[i].direction.x;
            var translateY = balls[i].ball.speed * clockDeltaTime * balls[i].direction.y;
            var translateZ = balls[i].ball.speed * clockDeltaTime * balls[i].direction.z;
            console.log(clockDeltaTime);
            balls[i].ball.position.x += translateX;
            balls[i].ball.position.y += 0;
            balls[i].ball.position.z += translateZ;
            console.log(balls[i].ball.position);
            //console.log(physicsItemsScript[i].dirXYZ)
            //physicsItems[i].position.add(physicsItemsScript[i].dirXYZ)
            balls[i].ball.speed = calculateSpeed(balls[i].ball.speed);
        }

    }

    function updateDirection(objDirection, impulseVector, add) {
        var newX, newZ;
        if (add == false) {
            newX = objDirection.x - impulseVector.x;
            //this.dirXYZ.y -= impulseVector.y;
            newZ = objDirection.z - impulseVector.z;
        }
        else {
            newX = objDirection.x + impulseVector.x;
            //this.dirXYZ.y += impulseVector.y;
            newZ = objDirection.z + impulseVector.z;
        }
        return new THREE.Vector3(newX, 0, newZ);
    }

    function calculateSpeed(speed) {
        if (speed > 0) {
            return speed -= 0.1;
        }
        else { return 0; }
    }

    function shootBall() {
        if (!ballsRoll()) {
            whiteball.ball.speed = 30;
            whiteball.direction = camera.getWorldDirection();
        }
    }

    function ballsRoll() {
        for (i = 0; i < balls.length; i++) {
            if (balls[i].ball.speed > 0) {
                return true;
            }
        }
        return false;
    }

    function setCamera() {
        if (ballsRoll()) {
            cue.position.z = 100;
            controls.target = poolGroup.position;
        }
        else {
            cue.position.z = 0.1;
            controls.target = whiteball.ball.position;
        }
    }

    function GetDistanceVector(objX, objY) {
        var deltaX = objX.x - objY.x;
        var deltaY = objX.y - objY.y;
        var deltaZ = objX.z - objY.z;

        return new THREE.Vector3(deltaX, deltaY, deltaZ);
    }

    function GetVectorNormal(vector, distance) {
        var normalX = vector.x / distance;
        var normalY = vector.y / distance;
        var normalZ = vector.z / distance;
        return new THREE.Vector3(normalX, normalY, normalZ);
    }

    function GetObjectVelocityDelta(objX, objY) {
        var deltaX = objY.direction.x * objY.ball.speed * frameDeltaTime - objX.direction.x - objX.ball.speed * frameDeltaTime;
        var deltaY = objY.direction.y * objY.ball.speed * frameDeltaTime - objX.direction.y - objX.ball.speed * frameDeltaTime;
        var deltaZ = objY.direction.z * objY.ball.speed * frameDeltaTime - objX.direction.z - objX.ball.speed * frameDeltaTime;
        return new THREE.Vector3(deltaX, deltaY, deltaZ);
    }

    function GetDotProduct(vector1, vector2) {
        var X = vector1.x * vector2.x
        var Y = vector1.y * vector2.y
        var Z = vector1.z * vector2.z
        return (X + Y + Z)
    }

    function GetImpulseVector(impulseStrength, vectorNormal) {
        var x = vectorNormal.x * impulseStrength;
        var y = vectorNormal.y * impulseStrength;
        var z = vectorNormal.z * impulseStrength;
        return new THREE.Vector3(x, y, z);
    }

    function onDocumentMouseMove(event) {
        event.preventDefault();

        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
    }

    // After loading JSON from our file, we add it to the scene
    function addModelToScene(geometry, materials) {
        var material = new THREE.MeshFaceMaterial(materials);
        model = new THREE.Mesh(geometry, material);
        model.scale.set(30, 30, 30);
        model.position.set(0, 6, 0);
        model.rotation.y = Math.PI / 2;
        model.castShadow = true;
        model.receiveShadow = true;
        //scene.add(model);
    }

    function Ball(name, texture, position) // Constructor
    {
        this.ball = new THREE.Mesh(new THREE.SphereGeometry(1, 20, 20));
        this.ball.material = texture;
        this.ball.position.x = position.x;
        this.ball.position.y = position.y;
        this.ball.position.z = position.z;
        this.direction = new THREE.Vector3(0, 0, 0);
        this.name = name;
        this.ball.speed = 0;
        this.ball.rotation.y = -1.5;
        scene.add(this.ball);
        return this;
    }

    function init() {

        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        renderer = new THREE.WebGLRenderer({ canvas: poolgame });
        renderer.setSize(1200, 800);
        renderer.setClearColor(0x000000);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;

        //BackgroundColor
        var backgroundMaterial = new THREE.MeshBasicMaterial({ color: 0x21aadf });
        var backgroundMaterial = new THREE.MeshPhongMaterial({ color: 0x21aadf });
        //BackgroundSize
        var background = new THREE.Mesh(new THREE.PlaneBufferGeometry(window.innerWidth, window.innerHeight, 2, 2), backgroundMaterial);
        background.position.y = -24;
        background.rotation.x = -Math.PI / 2;
        background.receiveShadow = true;
        scene.add(background);

        poolGroup = new THREE.Group();
        scene.add(poolGroup);

        // Load the JSON files and provide callback functions (modelToScene
        var modelloader = new THREE.JSONLoader();
        modelloader.load("models/pooltable.json", addModelToScene);

        //pooltable color
        var poolMaterial = new THREE.MeshPhongMaterial({ color: 0x07A127 });
        //Borders of the pooltable
        var shortGeometry = new THREE.BoxGeometry(42, 2, 2);
        b1 = new THREE.Mesh(shortGeometry, poolMaterial);
        b1.position.x = 0;
        b1.position.y = 0.5;
        b1.position.z = 40;
        b1.castShadow = true;
        b1.receiveShadow = true;
        poolGroup.add(b1);
        b2 = new THREE.Mesh(shortGeometry, poolMaterial);
        b2.position.x = 0;
        b2.position.y = 0.5;
        b2.position.z = -40;
        b2.castShadow = true;
        b2.receiveShadow = true;
        poolGroup.add(b2);
        var longGeometry = new THREE.BoxGeometry(2, 2, 80);
        b3 = new THREE.Mesh(longGeometry, poolMaterial);
        b3.position.x = 20;
        b3.position.y = 0.5;
        b3.position.z = 0;
        b3.castShadow = true;
        b3.receiveShadow = true;
        poolGroup.add(b3);
        b4 = new THREE.Mesh(longGeometry, poolMaterial);
        b4.position.x = -20;
        b4.position.y = 0.5;
        b4.position.z = 0;
        b4.rotation.z = Math.PI / 2;
        b4.castShadow = true;
        b4.receiveShadow = true;
        poolGroup.add(b4);
        //Pooltable
        var poolGeometry = new THREE.BoxGeometry(40, 1, 80);
        pooltable = new THREE.Mesh(poolGeometry, poolMaterial);
        pooltable.position.x = 0;
        pooltable.position.y = 0;
        pooltable.position.z = 0;
        pooltable.castShadow = true;
        pooltable.receiveShadow = true;
        poolGroup.add(pooltable);

        //Complete pooltable position;
        poolGroup.position.x = 0;
        poolGroup.position.y = 0;
        poolGroup.position.z = 0;

        //Load Textures
        var loader = new THREE.TextureLoader();

        var textureball1 = loader.load('textures/1.jpg');
        var textureball2 = loader.load('textures/2.jpg');
        var textureball3 = loader.load('textures/3.jpg');
        var textureball4 = loader.load('textures/4.jpg');
        var textureball5 = loader.load('textures/5.jpg');
        var textureball6 = loader.load('textures/6.jpg');
        var textureball7 = loader.load('textures/7.jpg');
        var textureball8 = loader.load('textures/8.jpg');
        var textureball9 = loader.load('textures/9.jpg');
        var textureball10 = loader.load('textures/10.jpg');
        var textureball11 = loader.load('textures/11.jpg');
        var textureball12 = loader.load('textures/12.jpg');
        var textureball13 = loader.load('textures/13.jpg');
        var textureball14 = loader.load('textures/14.jpg');
        var textureball15 = loader.load('textures/15.jpg');

        //cue
        var cueGeometry = new THREE.CylinderGeometry(0.1, 0.4, 30);
        var cueColor = new THREE.MeshPhongMaterial({ color: 0xb88b45 });
        cue = new THREE.Mesh(cueGeometry, cueColor);
        cue.castShadow = true;
        cue.receiveShadow = true;

        //Balls
        //White ball
        whiteball = new Ball("whiteball", new THREE.MeshPhongMaterial({ color: 0xffffee }), new THREE.Vector3(0, 1.5, 20));

        //Colored Balls
        //First row
        ball1 = new Ball("ball1", new THREE.MeshPhongMaterial({ map: textureball1 }), new THREE.Vector3(0, 1.5, -18));

        //Second row
        ball2 = new Ball("ball2", new THREE.MeshPhongMaterial({ map: textureball2 }), new THREE.Vector3(-1.1, 1.5, -20));
        ball3 = new Ball("ball3", new THREE.MeshPhongMaterial({ map: textureball3 }), new THREE.Vector3(1.1, 1.5, -20));

        //Third row
        ball4 = new Ball("ball4", new THREE.MeshPhongMaterial({ map: textureball4 }), new THREE.Vector3(-2.1, 1.5, -22));
        ball5 = new Ball("ball5", new THREE.MeshPhongMaterial({ map: textureball5 }), new THREE.Vector3(0, 1.5, -22));
        ball6 = new Ball("ball6", new THREE.MeshPhongMaterial({ map: textureball6 }), new THREE.Vector3(2.1, 1.5, -22));

        //Fourth row
        ball7 = new Ball("ball7", new THREE.MeshPhongMaterial({ map: textureball7 }), new THREE.Vector3(3.2, 1.5, -24));
        ball8 = new Ball("ball8", new THREE.MeshPhongMaterial({ map: textureball8 }), new THREE.Vector3(1, 1.5, -24));
        ball9 = new Ball("ball9", new THREE.MeshPhongMaterial({ map: textureball9 }), new THREE.Vector3(-1.1, 1.5, -24));
        ball10 = new Ball("ball10", new THREE.MeshPhongMaterial({ map: textureball10 }), new THREE.Vector3(-3.2, 1.5, -24));

        //Fifth row
        ball11 = new Ball("ball11", new THREE.MeshPhongMaterial({ map: textureball11 }), new THREE.Vector3(-4.3, 1.5, -26));
        ball12 = new Ball("ball12", new THREE.MeshPhongMaterial({ map: textureball12 }), new THREE.Vector3(-2.1, 1.5, -26));
        ball13 = new Ball("ball13", new THREE.MeshPhongMaterial({ map: textureball13 }), new THREE.Vector3(0, 1.5, -26));
        ball14 = new Ball("ball14", new THREE.MeshPhongMaterial({ map: textureball14 }), new THREE.Vector3(2.1, 1.5, -26));
        ball15 = new Ball("ball15", new THREE.MeshPhongMaterial({ map: textureball15 }), new THREE.Vector3(4.3, 1.5, -26));

        //Add balls to ballsArray;
        balls.push(whiteball);
        balls.push(ball1);
        balls.push(ball2);
        balls.push(ball3);
        balls.push(ball4);
        balls.push(ball5);
        balls.push(ball6);
        balls.push(ball7);
        balls.push(ball8);
        balls.push(ball9);
        balls.push(ball10);
        balls.push(ball11);
        balls.push(ball12);
        balls.push(ball13);
        balls.push(ball14);
        balls.push(ball15);

        camera.add(cue);
        cue.position.set(1.7, -0.4, -20);
        cue.rotation.x = -1.55;
        cue.rotation.y = 0;
        cue.rotation.z = 0.1;
        cue.position.applyMatrix4(camera.matrixWorld);

        //Elements need for movement and collision.
        speed = new THREE.Vector3();
        clock = new THREE.Clock();
        speedVariable = 0;

        //Lightning
        scene.add(new THREE.AmbientLight(0x111111));
        var sphere = new THREE.SphereGeometry(0.5, 16, 8);

        //Spotlight 1
        var light1 = new THREE.SpotLight(0xf0f0f0, 0.7, 100, Math.PI * 0.8);
        light1.add(new THREE.Mesh(sphere, new THREE.MeshBasicMaterial({ color: 0xf0f0f0 })));
        light1.position.set(8, 48, -16);
        light1.castShadow = true;
        light1.shadow.camera.near = 0.1;
        light1.shadow.camera.far = 1000;
        light1.shadow.mapSize.width = 1024;
        light1.shadow.mapSize.height = 1024;
        lightTarget1 = new THREE.Object3D();
        lightTarget1.position.set(8, -20, -16);
        light1.target = lightTarget1;
        scene.add(lightTarget1);
        scene.add(light1);

        //Spotlight 2
        var light2 = new THREE.SpotLight(0xf0f0f0, 0.7, 100, Math.PI * 0.8);
        light2.add(new THREE.Mesh(sphere, new THREE.MeshBasicMaterial({ color: 0xf0f0f0 })));
        light2.position.set(8, 48, 16);
        light2.castShadow = true;
        light2.shadow.camera.near = 0.1;
        light2.shadow.camera.far = 1000;
        light2.shadow.mapSize.width = 1024;
        light2.shadow.mapSize.height = 1024;
        lightTarget2 = new THREE.Object3D();
        lightTarget2.position.set(8, -20, 16);
        light2.target = lightTarget2;
        scene.add(lightTarget2);
        scene.add(light2);

        //Spotlight 3
        var light3 = new THREE.SpotLight(0xf0f0f0, 0.7, 100, Math.PI * 0.8);
        light3.add(new THREE.Mesh(sphere, new THREE.MeshBasicMaterial({ color: 0xf0f0f0 })));
        light3.position.set(-8, 48, -16);
        light3.castShadow = true;
        light3.shadow.camera.near = 0.1;
        light3.shadow.camera.far = 1000;
        light3.shadow.mapSize.width = 1024;
        light3.shadow.mapSize.height = 1024;
        lightTarget3 = new THREE.Object3D();
        lightTarget3.position.set(-8, -20, -16);
        light3.target = lightTarget3;
        scene.add(lightTarget3);
        scene.add(light3);

        //Spotlight 4
        var light4 = new THREE.SpotLight(0xf0f0f0, 0.7, 100, Math.PI * 0.8);
        light4.add(new THREE.Mesh(sphere, new THREE.MeshBasicMaterial({ color: 0xf0f0f0 })));
        light4.position.set(-8, 48, 16);
        light4.castShadow = true;
        light4.shadow.camera.near = 0.1;
        light4.shadow.camera.far = 1000;
        light4.shadow.mapSize.width = 1024;
        light4.shadow.mapSize.height = 1024;
        lightTarget4 = new THREE.Object3D();
        lightTarget4.position.set(-8, -20, 16);
        light4.target = lightTarget4;
        scene.add(light4);
        scene.add(lightTarget4);

        //Camera positioning
        camera.position.y = 20;
        camera.position.x = 0;
        camera.position.z = 70;
        //camera.lookAt(whiteball.position);
        scene.add(camera);

        //Camera controls
        controls = new THREE.OrbitControls(camera, renderer.domElement);
        //controls.addEventListener( 'change', render ); // add this only if there is no animation loop (requestAnimationFrame)
        controls.enableDamping = true;
        controls.dampingFactor = 0.25;
        controls.enableZoom = true;
        controls.target = poolGroup.position;
    }

	</script>
    
</body>
</html>
